\documentclass[]{article}
\usepackage{graphicx}
\graphicspath{{imagenes/}}
\usepackage[spanish]{babel}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{longtable}
\usepackage{tabularx}

% Configurar el color de los enlaces
\hypersetup{
    colorlinks=true, % Activa el color en los enlaces
    linkcolor=blue,  % Color para los enlaces internos (por ejemplo, tablas de contenido)
    citecolor=black,  % Color para las citas bibliográficas
    filecolor=blue,  % Color para enlaces a archivos
    urlcolor=blue    % Color para los enlaces a URLs
}


\definecolor{miverde}{rgb}{0,0.6,0}
\definecolor{miazul}{rgb}{0.5,0.5,1}
\lstdefinelanguage{cql}{
  morekeywords={SELECT, FROM, WHERE, INSERT, INTO, UPDATE, DELETE, CREATE, TABLE, PRIMARY, KEY, IF, EXISTS, NOT, NULL, AND, OR, SET, USE, VALUES, IN, ALLOW, FILTERING, AS}, % Palabras clave
    ndkeywords={COUNT, AVG},
    ndkeywordstyle=\color{miazul},
  sensitive=false, % Si las palabras clave distinguen mayúsculas de minúsculas
  morecomment=[l]--, % Comentarios de línea (prefijados con "--")
  morecomment=[s]{/*}{*/}, % Comentarios de bloque
  morestring=[b]', % Cadenas entre comillas simples
  morestring=[b]" % Cadenas entre comillas dobles
}


\lstdefinestyle{cql}{
    language=cql,
    backgroundcolor=\color{gray!2},     % Color de fondo
    basicstyle=\ttfamily,               % Tipo y tamaño de fuente
    keywordstyle=\color{blue}\bfseries, % Color para palabras clave
    stringstyle=\color{miverde},        % Color para cadenas
    commentstyle=\color{red},           % Color para comentarios
    showspaces=false,                   % No mostrar espacios
    showstringspaces=false,             % No mostrar espacios en las cadenas
    frame=single,                       % Poner un marco alrededor del código
    breaklines=true,                    % Romper las líneas largas
    captionpos=b,                       % Posición del caption
    tabsize=4,                          % Tamaño de las tabulaciones
    escapeinside={\%*}{*)},             % Para incluir código LaTeX en los listings
    morekeywords={self},                 % Palabras clave adicionales
    extendedchars=true,
    inputencoding=utf8
}

\lstdefinestyle{python}{
    language=Python,
    backgroundcolor=\color{gray!2},     % Color de fondo
    basicstyle=\ttfamily,               % Tipo y tamaño de fuente
    keywordstyle=\color{blue}\bfseries, % Color para palabras clave
    stringstyle=\color{miverde},        % Color para cadenas
    commentstyle=\color{red},           % Color para comentarios
    showspaces=false,                   % No mostrar espacios
    showstringspaces=false,             % No mostrar espacios en las cadenas
    frame=single,                       % Poner un marco alrededor del código
    breaklines=true,                    % Romper las líneas largas
    captionpos=b,                       % Posición del caption
    tabsize=4,                          % Tamaño de las tabulaciones
    escapeinside={\%*}{*)},             % Para incluir código LaTeX en los listings
    morekeywords={self}                 % Palabras clave adicionales
}
%title
\title{Práctica 1} 

\author{Adrián Ferández Galán, César López Mantecón y Manuel Gómez-Plana Rodríguez}

\begin{document}

\begin{titlepage}
    \centering
   \includegraphics[width=0.9\textwidth]{uc3m.jpg} 
    {\Huge Universidad Carlos III\\
    
     \Large Arquitectura de Datos\\
     \vspace{0.5cm}
     Curso 2024-25}
    \vspace{2cm}

    {\Huge \textbf{Práctica 2} \par}
    \vspace{0.5cm}
    {\Large Migración de una base de datos a \texttt{Cassandra} \par}
    \vspace{8cm}

   \textbf{Ingeniería Informática, Cuarto curso}\\
    \vspace{0.2cm} 
    Adrián Fernández Galán       (NIA: 100472182, e-mail: 100472182@alumnos.uc3m.es)\\
    César López Mantecón         (NIA: 100472092, e-mail: 100472092@alumnos.uc3m.es)\\
    Manuel Gómez-Plana Rodríguez (NIA: 100472310, e-mail: 100472310@alumnos.uc3m.es)
    \vspace{0.5cm}

   
    \textbf{Prof .} Lourdes Moreno López\\
    
    \textbf{Grupo: } 81   
    
\end{titlepage}
\newpage

\renewcommand{\contentsname}{\centering Índice}

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=blue}
\newpage

\section{Introducción}
\label{sec:introduccion}
En este documento se recoge el desarrollo de la práctica 2 de la asignatura
\textit{Arquitectura de Datos}. En esta práctica se tratará de completar una
migración de una base de datos desde \texttt{MongoDB} a \texttt{Cassandra}.
Además, se computarán nuevas tablas con el fin de permitir el análisis
estadístico, aprovechando las cualidades de \texttt{Cassandra} para el análisis
de datos gracias a su capacidad para la consulta masiva de datos de una misma
columna.

La metodología usada para el desarrollo de este proyecto ha sido la siguiente:
análisis de datos y casos de uso, realización del diseño lógico y físico
orientado a \texttt{Cassandra} e implementación de casos de uso en forma e
consulta. Adicionalmente se empleará la herramienta \texttt{PySpark} para
realizar el primer volcado de datos.

En el diseño de consultas se tratará de aprovechar al máximo las capacidades de
\texttt{Cassandra} en la lectura y escritura, dejando a la aplicación otra clase de
operaciones. De esta forma, ambos sistemas trabajarán en conjunto, garantizando
la eficiencia de la aplicación.


% =======
% Para la realización de esta práctica se busca realizar una migración de datos desde el gestor de bases de datos \textit{Mongodb} a \textit{Cassandra}, además de suplir una serie de casos de uso 
% 
% Esta práctica se basa en la migración de un sistema gestor de expedientes de sanciones que se encontraba en el gestor de bases de datos \textit{Mongodb} y se quiere mover a \textit{Cassandra}, además de implementar nuevos casos de uso. 
% Para ello se realizará un estudio de los datos almacenados en \textit{mongodb} y de los casos de uso propuestos. Tras esto se desarrollará un diseño lógico y físico de la base de datos en \textit{Cassandra} que nos faciliten la creación de las tablas en este mismo gestor de bases de datos y la implementación de las consultas enfocadas a los casos de uso.
% Con las tablas configuradas se insertarán los antiguos datos a través de la herramienta \textit{PySpark}, para finalmente probar el correcto funcionamiento del nuevo sistema.

\section{Modelo de Información del nuevo sistema}
\label{sec:modelo_informacion}

Para completar la migración es necesario realizar un estudio de los datos almacenados en el antiguo modelo. Como la anterior gestión de los datos se realizaba en el gestor de bases de datos \textit{MongoDB} se tiene un \texttt{json} con todos los datos.

Observando las características del \texttt{json} con la información del anterior sistema podemos sacar las siguientes conclusiones:
\begin{itemize}
    \item El antiguo sistema almacena registro sobre los vehículos que han circulado por diferentes autovías, este registro se ha hecho a través de grabaciones realizadas por los diferentes radares situados por las autovías.
    \item El sistema también gestiona sanciones ya emitidas como multas por velocidad (\textit{speed ticket}), cargos administrativos (\textit{clearance ticket}) y multas en zonas de radar de tramo (\textit{stretch ticket}).
    \item Para cada uno de los registros se pueden identificar los siguientes elementos:
    \begin{itemize}
        \item Una autovía o carretera
        \item Un radar en un kilometro determinado de la carretera
        \item Un vehículo que ha cruzado el radar
        \item El vehículo consta de información del conductor en ese momento y del propietario del vehículo
        \item Una grabación realizada por el radar sobre el vehículo en cuestión
    \end{itemize} 
\end{itemize}

Con el objetivo de entender el dominio del problema se ha creado un diagrama de clases en formato UML que nos permita entender los elementos que se tienen en el sistema y cómo estos se relacionan entre sí.

\section{Análisis de los Casos de Uso}
\label{sec:analisis_casos_de_uso}

Para poder desarrollar el nuevo sistema es necesario entender a la perfección
los casos de uso que se nos plantean. A continuación se analizan los
distintos casos de uso que se presentan.

Los casos de uso se pueden dividir según su finalidad:
\begin{itemize}
    \item \textbf{Por funciones operativas}: Aquellos casos de uso que tienen como objetivo generar nuevas funcionalidades.
    \item \textbf{Para análisis estadístico}: Aquellos casos de uso que tienen como objetivo organizar la información de tal manera que pueda realizarse un análisis estadístico sobre ella.
\end{itemize}

\subsection{Funciones Operativas}
\label{subsec:funciones_operativas}

Encontramos dos casos de uso enfocados a las funciones operativas.
\begin{itemize}
    \item \textbf{Emisión de sanciones:}
    
    Este caso de uso busca generar nuevas sanciones a aquellos conductores que no cumplen con una serie de condiciones relacionadas con la velocidad del coche durante el tramo de radar, la situación personal del conductor identificado, el estado de las revisiones técnicas del vehículos y otros factores.
    A continuación se realizará descripción de las condiciones que generarán una nueva sanción:
    \begin{itemize}
        \item \textit{Discrepancia en el carné de conducir del conductor}: En aquellos casos en los que la fecha de obtención del permiso de conducir no sea superior a la fecha de nacimiento del conductor en 18 años.
        \item \textit{Conducción con el vehículo deficiente}: Un coche se considera deficiente si en su última revisión se ha identificado algún defecto. 
        \item \textit{Impago de sanciones emitidas}: Se generará una nueva sanción a aquellos conductores no hayan realizado el pago durante la fecha prevista, dado que no se tiene el conocimiento de esta fecha se tomará una fecha que corresponda con la mediana de todas las fechas existentes en la base de datos.
    \end{itemize}

    Con el objetivo de cumplir este caso de uso se ha generado una tabla llamada \texttt{sanciones}. En esta tabla se recopilarán todas las sanciones de cualquier tipo, tanto generadas como las emitidas. Para ello se generará la siguiente tabla:
\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Sanciones}} \\ 
        \midrule
        dni\_deudor      & text & K \\
        tipo             & text & C↑\\
        fecha\_grabacion & date & C↓\\
        cantidad         & int  &   \\
        dni\_conductor   & text &   \\
        dni\_propietario & text &   \\
        estado           & text &   \\
        matrícula        & text &   \\
        \bottomrule
    \end{tabular}
    \caption {Tabla SANCIONES}
 \end{table}

    Tal y como funciona \textit{Cassandra} es necesario crear una tabla vaya de la mano de la consulta. Para satisfacer el caso de uso se realizará a través de la siguiente consulta:
    \lstset{style=cql}
    \begin{lstlisting}[language=cql, caption=Consulta de todas las sanciones]
SELECT * from Sanciones WHERE dni_deudor = '12345678X' AND tipo IN ('discrepancia carne', 'desperfectos', 'impago') 
    \end{lstlisting}

    Como se puede observar para poder realizar esta consulta en
    \textit{Cassandra} es necesario que el \textit{DNI} y \textit{Tipo} formen
    parte de la clave primaria de la tabla. Además, la elección de
    \textit{Fecha} como clave de \textit{clustering} permite ordenar todas las
    sanciones generadas y concede control en la unicidad de los registros. 

    \item \textbf{Apertura de un proceso ejecutivo para expedientes activos sin plazo de pago cerrado:}
    
    Este caso de uso busca identificar aquellos expedientes que continuan
    activos pero su plazo de pago no ha sido cerrado, para posteriormente abrir
    un proceso ejecutivo realizado por otro sistema de gestión de la DGT que
    permita avisar a los conductores para que realicen su pago. Esta
    funcionalidad se contempla en la siguiente consulta sobre la tabla
    anterior: 
\vspace{0.3cm}

\begin{lstlisting}[language=cql, caption=Consulta de las sanciones pendientes de pago]
SELECT * from Sanciones WHERE estado='stand_by' ALLOW FILTERING; 
\end{lstlisting}

En este caso es necesario incluir la \textit{flag} \texttt{ALLOW FILTERING} debido a que las claves primaria y de clustering no forman parte de la condición de búsqueda. Sin embargo, ya que es necesario comprobar todos los registros para extraer aquellos con el estado adecuado no presenta un problema.
\end{itemize}

\subsection{Análisis Estadístico}
\label{subsec:analisis_estadistico}

Para el análisis estadístico la DGT está interesada en los siguientes estudios:
\begin{itemize}
    \item Estudio por marcas y modelos

    Este caso de uso busca realizar un estudio sobre las marcas y modelos de coches que más infracciones cometen. Es por ello que se exigen tres análisis:
    
    \begin{enumerate}
        \item Número de multas por marca y modelo del vehículo
        \item Los tres colores más multados de coches
        \item Las marcas y modelos de los vehículos con más infracciones por velocidad
    \end{enumerate}

    Se han elaborado dos tablas distintas sobre las que hacer las consultas en \texttt{Cassandra} que permitan obtener cada una de estas estadísticas. Las tablas tienen la siguiente forma:
\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Multas por marca y modelo}} \\ 
        \midrule
        marca              & text & K\\
        modelo             & text & K\\
        matricula          & text & C↓\\
        fecha\_grabacion   & text & C↓\\
        tipo               & text &  \\
        \bottomrule
    \end{tabular}
    \caption {Tabla MULTAS\_MARCA\_MODELO}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Multas por color}} \\ 
        \midrule
        color            & text & K\\
        matricula        & text & C↓\\
        fecha\_grabacion & date & C↓\\
        \bottomrule
    \end{tabular}
    \caption {Tabla MULTAS\_COLOR}
\end{table}
    
    La primera tabla recoge todas las sanciones con la marca y el modelo como claves de partición. De esta forma la consulta relativa a este caso de uso será más eficiente.

    A continuación se incluyen las consultas realizadas sobre estas tablas:

    \lstset{style=cql}
    \begin{lstlisting}[language=cql, caption=Querys para el caso de uso 1]
// Query para el numero de multas por marca y modelo
SELECT marca, modelo, COUNT(*) as total_multas FROM multas_marca_modelo GROUP BY marca, modelo;

// Query para el numero de multas por color
SELECT color, COUNT(*) as total_multas from multas_color_coche GROUP BY color;

// Query para sacar las marcas y modelos de los vehiculos con mas infracciones por velocidad
SELECT marca, modelo, COUNT(*) as total_multas FROM multas_marca_modelo WHERE tipo = 'velocidad' GROUP BY marca, modelo ALLOW FILTERING;
    \end{lstlisting}

    Para la primera y tercera consulta, se obtienen directamente los datos que
    se piden para el caso de uso. En el caso de la consulta 2, se obtienen
    todas las multas para cada color y se deja como responsabilidad de la
    aplicación obtener los tres registros con mayor número de multas. Esto último
    es necesario ya que \texttt{Cassandra} sólo soporta ordenar en una única
    partición. No obstante, los datos de esta consulta podrían estar
    distribuidos en varios nodos.

    \item Estudio por carreteras

    Este caso de uso busca realizar un estudio sobre las carreteras más
    conflictivas de España, haciendo un análisis del exceso de velocidad medio
    en carreteras, así como los tramos donde más infracciones se han cometido.
    Es por ello que se pide lo siguiente:

    \begin{enumerate}
        \item Exceso de velocidad medio para una carretera determinada
        \item Tramo y sentido más conflictivo de una carretera 
    \end{enumerate}

    Se han elaborado dos tablas distintas sobre las que hacer las consultas en
    \texttt{Cassandra} que permitan obtener cada una de estadísticas. Las
    tablas tienen la siguiente forma:  

    \begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Exceso de Velocidad Medio Por Carretera}} \\ 
            \midrule
            carretera        & text & K\\
            fecha\_grabacion & date & C↓\\
            velocidad\_registrada & int & \\
            velocidad\_limite\_radar & int & \\
            \bottomrule
        \end{tabular}
        \caption {Tabla EXCESO\_VELOCIDAD\_CARRETERA}
    \end{table}

    \begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Tramo y Sentido más Conflicto por Carretera}} \\ 
            \midrule
            carretera     & text & K\\
            fecha\_grabacion & date & C↓\\
            kilometro     & int & \\
            sentido       & text& \\
            \bottomrule
        \end{tabular}
        \caption {Tabla CONFLICTO\_TRAMO\_SENTIDO}
    \end{table}

    Las consultas para obtener las estadísticas son las siguientes:

    \begin{lstlisting}[language=cql, caption=Consultas para el caso de uso 2]
// Query para el exceso de velocidad medio para una carretera determinada
SELECT carretera, AVG(velocidad_registrada) as media_velocidad_registrada, AVG(velocidad_limite_radar) as media_velocidad_radar FROM exceso_velocidad_carretera GROUP BY carretera;

// Query para el tramo y sentido mas conflictivo de una carretera
SELECT carretera, kilometro, sentido, COUNT(*) as infracciones_tramo FROM conflictos_tramo_sentido GROUP BY carretera, kilometro, sentido;
    \end{lstlisting}

    La primera consulta devuele el promedio de las velocidades esperadas en un tramo y las registradas para conches infractores. La segunda consulta permite conocer el número de infracciones para cada tramo de cada carretera, de forma que la aplicación pueda seleccionar aquellos registros con mayor número de multas.

    Adicionalmente, se puede modificar ligeramente la consulta en caso de querer seleccionar los registros para una única carretera. En este caso sería necesario usar la \textit{flag} \texttt{ALLOW FILTERING} debido a que la condición where no agrupa todos los atributos de la clave de partición. 

\begin{lstlisting}[language=cql, caption=Querys modificada para el caso de uso 2]
// Query para el tramo y sentido mas conflictivo de una carretera concreta
SELECT carretera, kilometro, sentido, COUNT(*) as infracciones_tramo FROM conflictos_tramo_sentido  where carretera = 'A2' GROUP BY carretera, kilometro, sentido ALLOW FILTERING;
    \end{lstlisting}

 
    \item Estudio por conductores

    El último caso de uso busca realizar un estudio sobre los conductores,
    concretamente, buscan determinar los conductores más infractores, así como
    la probabilidad de que se cometa una infracción cuando un vehículo no es
    conducido por el dueño del mismo.

    Para determinar qué conductores son los más infractores se ha diseñado la siguiente consulta sobre la tabla sanciones:
    \begin{lstlisting}[language=cql, caption=Consulta para obtener los conductores más infractores]
SELECT dni_deudor, COUNT(*) as num_multas FROM sanciones GROUP BY dni_deudor;
    \end{lstlisting}

    Esta consulta devuelve el número de infracciones para cada conductor, de forma que la aplicación pueda seleccionar fácilmente el valor más alto del registro.

    Para obtener la probabilidad de que un infractor sea el propietario del coche se ha diseñado una tabla adicional con la siguiente forma:

    \begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Probabilidad de infracción}} \\ 
            \midrule
            conductor\_igual\_propietario & boolean & K\\
            matricula        & text      & C↓\\
            fecha\_grabacion & timestamp & C↓\\
            \bottomrule
        \end{tabular}
        \caption {Tabla CONDUCTORES\_MAS\_INFRACTORES}
     \end{table}

    El valor requerido es el resultado de la siguiente fórmula: 

    $$P = \frac{\text{num\_conductor\_eq\_propietario}}{\text{num\_multas}}$$

    Estos dos valores se pueden obtener fácilmente mediante dos consultas:

    \begin{lstlisting}[language=cql, caption=Querys para el caso de uso 3]
// Obtencion del numero de multas totales
SELECT COUNT(*) FROM sanciones;
// Obtencion del numero de infracciones con conductor = propietario
select conductor_igual_propietario, count(*) from probabilidad_infraccion GROUP BY conductor_igual_propietario;
    \end{lstlisting}
\end{itemize}

    Con ambos valores la aplicación puede calcular el valor requerido, garantizando la resolución eficiente de este caso de uso.

\section{Modelo Lógico y Físico}
\label{sec:modelo_logico_fisico}

Tras presentar los casos de uso y cómo estos casos de uso derivan en sus
respectivas consultas y tablas, estudiaremos cómo se ha realizado el modelo
completo del sistema para conseguir que dichas tablas se carguen con
los datos necesarios.

\subsection{Modelo Lógico}

\subsubsection{Sanciones}

El primer enfoque que se ha considerado es conseguir alimentar la tabla
\textbf{Sanciones} con aquellas personas que tenga algún tipo de sanción. Por
lo que para alimentar esta tabla tenemos que tratar dos grupos de sanciones:
sanciones generadas y sanciones emitidas previamente.

\begin{itemize}
    \item \textbf{Sanciones ya generadas}: En los datos originales encontramos
    sanciones ya emitidas con anterioridad como lo son \textit{Speed Ticket},
    \textit{Clearance Ticket} y \textit{Stretch Ticket}, por lo que ha creado
    un \textit{dataframe} en \textit{Pyspark} para cada una de estas multas.

    \item \textbf{Nuevas sanciones}: Para generar nuevas sanciones se han
    contemplado las condiciones descritas en el punto \ref{subsec:funciones_operativas}.
    Para cada una de
    ellas se ha generado un \textit{dataframe} en \textit{Pyspark} que parte de
    los datos del \textit{JSON}, excepto en el caso de \textit{impago de
    sanciones} que utilizará los dataframes de las multas para conocer qué
    conductores deben de recibir otra infracción. En cada uno de los
    \textit{dataframes} se insertarán los datos que cumplan la condición, de
    manera que solo contengan los datos de aquellos conductores infractores.
    Finalmente los \textit{dataframes} creados han sido los siguientes:
    \texttt{Discrepancia\_Carnet}, \texttt{Vehiculo\_Deficiente},
    \texttt{Impago\_Sanciones}
\end{itemize}

Cada de uno de los \textit{dataframes} mencionados tendrá únicamente los
atributos necesarios para alimentar la tabla de \textit{Sanciones} y cualquier
otra tabla que satisfaga a un caso de uso.
La tabla \textit{Sanciones} será la unión de algunos atributos de cada una de
los \textit{dataframes} mencionados. Tal como se ha indicado en el anterior
punto, \textit{Sanciones} cuenta con los atributos \texttt{dni\_deudor},
\texttt{dni\_propietario}, \verb!dni_conductor!, \verb!fecha_grabacion!,
\verb!matricula!, \verb!cantidad!, y \verb!estado!; por lo que será necesario que los \textit{dataframes} tengan esta
información, o al menos pueda ser obtenida de algún modo. Esta nueva tabla será
insertada en \texttt{Cassandra}.

Para ello los \textit{dataframes} anteriores contarán con \texttt{dni\_deudor}, \texttt{fecha\_grabación}, \texttt{matricula}; y si son sanciones emitidas previamente se usará su estado, tipo y cantidad, en cambio para las sanciones generadas se les dotará de una cantidad, el estado de \texttt{stand\_by} y el tipo según la procedencia de la multa.

A continuación se puede ver un diagrama que recoge el proceso de migración para la creación de la tabla \textit{Sanciones}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./imagenes/Sanciones.png}
    \caption{Modelo lógico de Sanciones}
    \label{fig:modelo_sanciones}
\end{figure}

En verde se representan los \textit{dataframes} auxiliares que se construyen en \textit{Pyspark}.

\subsubsection{Multas por marca y modelo o por color}

Estas dos tablas se alimentan de datos de los vehículos y de las sanciones.
Para cumplir con la funcionalidad descrita en los casos de uso y tal y cómo se
expuso en el punto \ref{subsec:analisis_estadistico} es necesario que estas
tablas contengan los siguientes datos: 

\begin{itemize}
    \item\textbf{Multas por marca y modelo}: \verb!matricula!, \verb!modelo!,
    \verb!marca!, \verb!fecha_grabacion! y \verb!tipo_multa!.
    \item\textbf{Multas por color}: \verb!color!, \verb!fecha_grabacion! y \verb!matricula!.
\end{itemize}

El proceso de migración que se ha seguido para alimentar estas tablas viene recogido en el siguiente diagrama:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{./imagenes/multas_estadistica.png}
    \caption{Modelo lógico de Multas por Color y Multas por marca y modelo}
\end{figure}

\subsubsection{Tramo conflictivo y exceso de velocidad medio}

Las tablas con información relativa al tramo más conflictivo y el exceso de velocidad medio contienen los siguientes datos: 

\begin{itemize}
    \item\textbf{Tramo conflictivo}: \verb!carretera!, \verb!kilometro!, \verb!sentido! y \verb!fecha_grabacion!.
    \item\textbf{Exceso de velocidad medio}: \verb!carretera!, \verb!velocidad_registrada!, \verb!velocidad_limite_radar! y \verb!fecha_grabacion!.
\end{itemize}

Es por eso que necesitan alimentarse exclusivamente de información relativa a las multas por exceso de velocidad, tal y como se representa en el siguiente diagrama:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./imagenes/tramo_y_velocidad.png}
    \caption{Modelo lógico de Tramos conflictivos y Exceso de velocidad medio}
\end{figure}

\subsubsection{Probabilidad de infracción}

La tabla con información relativa al caso de uso 3, es decir, el análisis de la probabilidad de infracción cuando el conductor de un vehículo multado es distinto al propietario, contiene los siguientes datos: 
\begin{itemize}
    \item\textbf{Conductor igual a propietario}: \verb!conductor_igual_propietario!, \verb!matricula!, y \verb!fecha_grabacion!.
\end{itemize}

Es por ello que necesitan obtener estos datos de la tabla de sanciones, explicada anteriormente,tal y como se puede observar en la siguiente figura:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.25\textwidth]{./imagenes/conductores.png}
    \caption{Modelo lógico de la Probabilidad de multa con conductor igual a propietario}
\end{figure}

\subsubsection{Diagrama completo}

Con todo lo anterior, el diagrama que representa la nueva base de datos, así como el proceso de migración es el siguiente:

%\begin{figure}[H]
%    \centering
%    \includegraphics[width=0.8\textwidth]{./imagenes/diagram.png}
%    \caption{Modelo lógico de Tramos conflictivos y Exceso de velocidad medio}
%\end{figure}

\subsection{Modelo físico}
\label{subsec:modelo_fisico}
\subsubsection{Dimensionamiento}
\label{subsubsec:dimensionamiento}
Con el objetivo de entender y analizar la escalabilidad de nuestros sistema, el nivel de optimización del sistema y el balanceo de la carga de trabajo, se calcularán los tamaños de las particiones.

Para conocer el número de celdas (valores) que tiene cada partición usaremos la siguiente fórmula: $$N_v = N_r \cdot (N_c - N_{pk} - N_s) + N_s$$
\begin{itemize}
    \item $N_v$: Número de valores en la partición
    \item $N_s$: Número de columnas estáticas
    \item $N_r$: Número de filas
    \item $N_c$: Número de columnas
    \item $N_pk$: Número de columnas en la pk
\end{itemize}

Con esta fórmula calcularemos el número de valores de cada partición para cada una de las tablas. Para entender cómo se realizarán los cálculos se se desarrollará la fórmula para una tabla, en este caso utilizaremos la tabla \textbf{Sanciones}:
\begin{itemize}
    \item Nº de columnas: $N_c = 8$
    \item Nº de columnas en pk: $N_{pk} = 3$
    \item Nº de columnas estáticas: $N_s= 0$
    \item Nº de filas: $N_r = 114049$
\end{itemize}

Obtenidos los datos para la fórmula, sustituimos $$114049 \cdot (8 - 3 - 0) + 0 = 570245 \text{filas por partición}$$

A continuación se muestran los valores por partición para cada tabla:
\begin{itemize}
    \item \textbf{Sanciones}: 570245
    \item \textbf{Multas por Marca y Modelo}: 48725
    \item \textbf{Multas por Color}: 1
    \item \textbf{Conductor igual a propietario}: 1
    \item \textbf{Tramo y Sentido más conflictivo por carretera}: 88362
    \item \textbf{Exceso de Velocidad medio por carretera}: 88362
\end{itemize}
Es importante destacar que para las tablas donde todas las columnas forman parte de la clave primaria, aunque la formula resulte en $0$, se ha tomado el valor $1$, dado que cada fila insertada se ubicará en una partición.

Tras calcular el número de filas por partición calcularemos el tamaño en disco de las tablas, esto se conseguirá a través de la siguiente fórmula: $$S_t = \sum_i sizeOf(c_k) + \sum_j sizeOf(c_{s_j}) + N_r \cdot (\sum_k sizeOf(c_{r_k}) + \sum_l sizeOf(c_{c_l})) + N_v \cdot sizeOf(t_{avg})$$

\begin{itemize}
    \item $c_k$: Cuenta las columnas que son clave de partición
    \item $c_s$: Cuenta las columnas estáticas
    \item $c_r$: Cuenta las columnas normales
    \item $c_c$: Cuenta las columnas que pertenecen a la clave de clusterización
    \item $t_avg$: Promedio de bytes utilizados por Cassandra para almacenar los metadatos de un valor, suele ser 8 bytes
    \item La función $sizeOf()$ indica el tamaño en bytes de los tipos CQL utilizados en la definición de cada columna
\end{itemize}

Al igual que para el anterior cálculo, se desarrollará en profundidad el cálculo del tamaño de una partición de una tabla, de nuevo usaremos \textbf{Sanciones}:
\begin{itemize}
    \item No tiene columnas estáticas ($c_s = 0$)
    \item Cálculo de bytes por columna
    \begin{itemize}
        \item DNI deudor, es de tipo texto con 9 simbolos = 9 bytes
        \item DNI propietario, 9 bytes
        \item DNI conductor, 9 bytes
        \item Tipo, es de tipo texto y la cadena más larga puede ser de 19 caracteres = 19 bytes
        \item Fecha, timestamp = 8 bytes
        \item Estado, es de tipo texto y la cadena más larga es "fullfied" que tiene 10 caracteres = 10 bytes
        \item Matricula, 7 caracteres = 7 bytes
        \item Cantidad, int = 4 bytes
    \end{itemize}
    \item Suma de columnas de clave de partición = 9 bytes
    \item Suma de columnas de clave de clusterización = 27 bytes
    \item Suma de columnas normales = 29 bytes
\end{itemize}

Con los valores calculados sustituimos en la fórmula $$S_t = 9 + 0 + 114049 \cdot (39 + 27) + 570245 \cdot 8 = 10948713 bytes = 12.09 MB$$
A continuación se muestran los tamaños de las particiones de las siguientes tablas:
\begin{itemize}
    \item \textbf{Sanciones}: 12.09 MB
    \item \textbf{Multas por Marca y Modelo}: 2.05 MB
        %marca = Supuesto de 15 bytes
        %modelo = Supuesto de 15 bytes
        %matricula = 7 bytes
        %Fecha = 8 bytes
        %Tipo = 19 bytes
        %N_r = 48725
    \item \textbf{Multas por Color}: 0.73 MB
        %color = Supuesto de 20 bytes
        %Fecha = 8 bytes
        %Matricula = 7 bytes
        %N_r = 48725
    \item \textbf{Conductor igual a propietario}: 0.73 MB
        % Conductor = propietario = 1 bytes (bool)
        % Matricula = 7 bytes
        % Fecha = 8 bytes
        %N_r = 48725
    \item \textbf{Tramo y Sentido más conflictivo por carretera}: 1.5 MB
        %Carretera = Supuesto de 8 bytes
        %Kilometro = 4 bytes (int)
        %Sentido = 10 bytes (text, "descending" son 10 caracteres)
        %Num_infrac = 4 bytes (int)
        %N_r = 44181
    \item \textbf{Exceso de Velocidad medio por carretera}: 1.41 MB
        %Carretera = Supuesto de 8 bytes
        %Fecha = 8 bytes
        %Velocidad registrada = 4 bytes (int)
        %Velocidad radar = 4 bytes (int)
        %N_r = 44181
\end{itemize}

Se ha supuesto que la marca y el modelo no superarán los 15 caracteres, que el color de los vehiculos no superará los 20 caracteres y que el nombre de la carretera no supera los 8 caracteres.



El límite de tamaño de una partición en Cassandra es de 2GB, pero se recomienda que el tamaño sea de 1MB. En nuestro caso todas las tablas tienen una gran holgura respecto al tamaño máximo de una partición, sin embargo únicamente 2 tablas no exceden el tamaño recomendado. Dos tablas que exceden el tamaño recomendado no lo exceden por mucho, únicamente por 0.5 MB, no obstante, la tabla \textbf{Sanciones} supera en un 1200\% el tamaño recomendado, por lo que sería una tabla en la que poner el foco.

¿Cómo se podría solucionar el excesivo tamaño de la tabla \textbf{Sanciones}? La propuesta más sencilla es añadir una de las columnas normales como clave de partición, en este caso podríamos añadir a la clave de partición el atributo \textit{Matricula}, de esta manera podemos conocer las sanciones que tiene una persona según los coches que tenga. Este cambio reduce el número de filas por partición de 570245 a \textbf{456196}, lo que supone que el tamaño de cada partición sea de \textbf{10.38 MB}, lo que supone una reducción del \textbf{14\%} del tamaño con tan solo cambiar un atributo.
Esto no es suficiente, pero se podrían proponer nuevas propuestas para mejorar más esta tabla, hasta llegar al tamaño recomendado. 

\newpage
\section{Implementación y carga de las tablas}
\label{sec:implementacion}
Una vez analizados los casos de uso y definididas tanto las consultas como las tablas, es necesario tratar la implementación de esta base de datos. Como se ha mencionado en puntos anteriores, se ha usado PySpark para la carga y algo de preprocesado de la información original. Es por ello que este apartado trata en detalle el script creado para la carga de datos, así cómo un breve análisis de los resultados.

\subsection{Carga de datos en PySpark}
El primer paso para realizar la carga de datos en las tablas es crear una sesión de PySpark para leer los datos del \textit{JSON} original. Para esto, primero hay que parsear el fichero original para que PySpark lo pueda procesar, algo que se ha realizado con la ayuda de un script extra que se encarga de introducir cada uno de los documentos originales en una lista, añadiendo los separadores entre documentos. Esto se ha realizado mediante el siguiente código:

\lstset{style=python}
\begin{lstlisting}[language=python, caption=Parseo del JSON original]
import re

with open("./data/sample.json", "r", encoding="ISO-8859-1") as f:
    file_content = f.read()
    file_parsed = re.sub(r"(?<!}\s)\n(?!\s{)", "", file_content)
    file_parsed = re.sub(r" +", " ", file_parsed)
    file_parsed = re.sub(r"\n(?!\s])", ",\n", file_parsed)

with open("./data/sample_parsed.json", "w", encoding="utf-8") as f:
    f.write(file_parsed)
\end{lstlisting}

Una vez que se han obtenido los datos parseados, se cargan en una sesión de PySpark de la siguiente manera:

\begin{lstlisting}[language=python, caption=Carga de datos en PySpark]
# ----- CREACION DE LA SESION DE PYSPARK -----
spark = SparkSession.builder \
    .appName("CargaDatos") \
    .config("spark.cassandra.connection.host", "127.0.0.1") \
    .config("spark.cassandra.connection.port", "9042") \
    .getOrCreate()

# ----- LECTURA DE FICHERO -----

# Leer el archivo NDJSON
json_df = spark.read.json(file_path)

# Aplicar la funcion al DataFrame original
json_df = rename_columns(json_df)
\end{lstlisting}

\subsection{Creación de las tablas intermedias}
Una vez que se han cargado los datos, es necesario crear las tablas en PySpark que servirán para alimentar las tablas explicadas en el apartado anterior. Las tablas de PySpark se corresponden con las tablas de color verde de los diagramas del punto 4. Todas estas tablas se realizan de la misma manera, por lo que se usará la tabla de \textit{speed tickets} como ejemplo al ser la más extensa. La creación de las tablas de PySpark se realiza de la siguiente manera:

\begin{lstlisting}[language=python, caption=Carga de datos en PySpark]
# Seleccionar las columnas para la nueva tabla de velocidad
speed_ticket = json_df.filter(col("radar.speed_limit") < col("Record.speed")).select(
    col("Speed_ticket.Debtor.DNI").alias("dni_deudor"),
    col("vehicle.Owner.DNI").alias("dni_propietario"),
    col("vehicle.Driver.DNI").alias("dni_conductor"),
    col("Speed_ticket.Pay_date").alias("fecha_pago"),
    col("Speed_ticket.Amount").alias("cantidad"),
    concat(col("Record.date"), lit(" "), col("Record.time")).alias("fecha_grabacion"),
    col("road.name").alias("carretera"),
    col("radar.mileage").alias("kilometro"),
    col("radar.direction").alias("sentido"),
    col("road.speed_limit").alias("velocidad_limite_carretera"),
    col("radar.speed_limit").alias("velocidad_limite_radar"),
    col("Record.speed").alias("velocidad_registrada"),
    col("vehicle.number_plate").alias("matricula"),
    col("Speed_ticket.State").alias("estado")
)
\end{lstlisting}

\subsection{Creación de las tablas finales}
Al conseguir las tablas que servirán para alimentar las tablas sobre las que haremos las consultas, se pueden construir las tablas finales. De la misma manera que en el apartado anterior, todas se realizan de la misma manera, por lo que se usará la tabla de \textit{sanciones} como ejemplo al ser la más extensa. Estas tablas normalmente requieren de uniones entre los datos, creando así una generación muy extensa, por lo que se decidió crear una función para la generación de cada tabla, las cuáles cuentan con una estructura similar a la siguiente:

\begin{lstlisting}[language=python, caption=Carga de datos en PySpark]
def gen_sanciones():

    # Calcula los speeding tickets
    speed = speed_ticket.select("dni_deudor", "dni_propietario", "dni_conductor", "fecha_grabacion", "estado", "matricula", "cantidad").withColumn("tipo", lit("velocidad"))

    # Calcula los clearence tickets
    clearance = clearance_ticket.select("dni_deudor", "dni_propietario","dni_conductor", "fecha_grabacion", "estado", "matricula", "cantidad").withColumn("tipo", lit("clearance"))

    # Calcula los stretch ticket
    stretch = clearance_ticket.select("dni_deudor", "dni_propietario","dni_conductor", "fecha_grabacion", "estado" ,"matricula", "cantidad").withColumn("tipo", lit("stretch"))

    # Obtiene impago y reorganiza
    impago = impago_sanciones.select("dni_deudor","dni_propietario", "dni_conductor", "fecha_grabacion", "cantidad", "matricula").withColumn("tipo", lit("impago")).withColumn("estado", lit("stand by"))
    impago = impago.select("dni_deudor", "dni_propietario", "dni_conductor", "fecha_grabacion", "estado", "matricula", "cantidad", "tipo")

    # Obtiene carne y reorganiza
    carne = discrepancia_carne.select("dni_propietario", "dni_conductor", "fecha_record", "matricula").withColumn("tipo", lit("discrepancia carne")).withColumn("estado", lit("stand by")).withColumn("cantidad", lit(1000)).withColumn("dni_deudor", discrepancia_carne["dni_conductor"])
    carne = carne.select("dni_deudor", "dni_propietario", "dni_conductor", "fecha_record", "estado", "matricula", "cantidad", "tipo")

    # Obtiene desperfectos y reorganiza
    desperfectos = vehiculo_deficiente.select("dni_propietario", "dni_conductor", "fecha_record", "matricula").withColumn("tipo", lit("discrepancia carne")).withColumn("estado", lit("stand by")).withColumn("cantidad", lit(1000)).withColumn("dni_deudor", vehiculo_deficiente["dni_propietario"])
    desperfectos = desperfectos.select("dni_deudor", "dni_propietario", "dni_conductor", "fecha_record", "estado", "matricula","cantidad", "tipo")

    return speed.union(clearance).union(impago).union(stretch).union(carne).union(desperfectos)
\end{lstlisting}

\subsection{Inserción de las tablas en Cassandra}
Una vez que se tienen las tablas finales creadas en PySpark, se procede al último paso, la inserción de datos en Cassandra. Para ello, se define una función que se encarga de escribir en Cassandra una tabla, la cuál tiene la siguiente forma:

\begin{lstlisting}[language=python, caption=Carga de datos en PySpark]
def write_to_cassandra(table, name, mode):
    table.write.format("org.apache.spark.sql.cassandra")\
    .options(table=name, keyspace=KEYSPACE)\
    .mode(mode)\
    .save()
\end{lstlisting}

Un problema encontrado en la inserción fueron las fechas de las grabaciones. Para poder insertar una fecha que lograse alcanzar una mayor individualidad a las multas, se decidió juntar la fecha de grabación con el tiempo, logrando así un timestamp para las fechas. Para poder insertar estos datos correctamente, fue necesario cambiar el tipo de las columnas, algo que se realizó con la siguiente función:

\begin{lstlisting}[language=python, caption=Carga de datos en PySpark]
def convertir_formato_fecha(df, columna_fecha):
    """
    Convierte el formato de una columna de fechas a timestamps

    :param df: DataFrame de PySpark
    :param columna_fecha: Nombre de la columna que contiene las fechas a convertir
    :return: DataFrame con la columna de fecha convertida
    """
    # Convertir la columna de fecha a formato timestamp
    df_converted = df.withColumn(
        columna_fecha,
        to_timestamp(col(columna_fecha), 'dd/MM/yyyy HH:mm:ss.SSS')
    )

    return df_converted
\end{lstlisting}

Con estos pasos, se consiguió insertar los datos en Cassandra.

\subsection{Prueba de las querys}
Para probar que las tablas de cassandra funcionan, es necesario comprobar que las querys explicadas con anterioridad funcionan de acuerdo a lo exigido por los casos de uso en el enunciado. Así, se ejecutarán las querys y se mostraran algunas filas que sirvan como ejemplo de salida.

\subsubsection{Query de las función operativa}
Se han obtenido los siguientes resultados para la query de las función operativa sobre los expedientes activos sin plazo de pago cerrado:

\begin{table}[H]
\begin{longtable}{lllll}
    \hline
    \textbf{dni\_deudor} & \textbf{tipo} & \textbf{fecha\_grabacion} & \textbf{estado} & \textbf{matricula} \\ \hline
    \endfirsthead
    
    \hline
    \textbf{dni\_deudor} & \textbf{tipo} & \textbf{fecha\_grabacion} & \textbf{estado} & \textbf{matricula} \\ \hline
    \endhead
    
    63050842E & discrepancia carne & 2008-03-12 02:04:01 & stand by & 2955AUA \\ \hline
    63050842E & discrepancia carne & 2008-08-05 09:10:31 & stand by & 2955AUA \\ \hline
    63050842E & discrepancia carne & 2008-09-09 14:26:53 & stand by & 2955AUA \\ \hline
    63050842E & discrepancia carne & 2008-09-14 20:23:03 & stand by & 2955AUA \\ \hline
    63050842E & discrepancia carne & 2009-02-13 14:08:57 & stand by & 2955AUA \\ \hline
    63050842E & discrepancia carne & 2009-02-27 20:08:44 & stand by & 2955AUA \\ \hline
    
\end{longtable}
\caption{Resumen de las multas en proceso de pago}
\end{table}

Como se puede observar, todas las filas tienen el estado ``stand by'', que cumple con lo pedido en el enunciado.

\subsubsection{Querys del análisis estadístico 1}
Se han obtenido los siguientes resultados para las querys del análisis estadístico 1:

\begin{itemize}
    \item \textbf{Multas por marca y modelo}

\begin{table}[H]
\begin{longtable}{l l l}
    \hline
    \textbf{marca} & \textbf{modelo} & \textbf{total\_multas} \\ \hline
    \endfirsthead
    
    \hline
    \textbf{marca} & \textbf{modelo} & \textbf{total\_multas} \\ \hline
    \endhead
    
    Zitron & Tangerine & 1930 \\ \hline
    Bemev & Berlin & 2528 \\ \hline
    Rinaul & Fuente & 3370 \\ \hline
    Zitron & Orange & 1178 \\ \hline
    Escola & Tercius & 841 \\ \hline
    
\end{longtable}
\caption{Resumen de las multas por marca y modelo}
\end{table}

Como se puede observar, se agrupan el número de sanciones por marca y modelo de vehículo de una manera correcta.

    \item \textbf{Multas por color}

\begin{table}[H]
\begin{longtable}{l l}
    \hline
    \textbf{color} & \textbf{total\_multas} \\ \hline
    \endfirsthead
    
    \hline
    \textbf{color} & \textbf{total\_multas} \\ \hline
    \endhead
    
    azul & 1876 \\ \hline
    dorado metalizado & 1352 \\ \hline
    ocre metalizado & 162 \\ \hline
    gris & 3989 \\ \hline
    marron metalizado & 464 \\ \hline

\end{longtable}
\caption{Resumen de las multas por color}
\end{table}

Como se puede observar, se agrupan el número de sanciones por color de vehículo de una manera correcta.

    \item \textbf{Multas de velocidad por marca y modelo}

\begin{table}[H]
\begin{longtable}{l l l}
    \hline
    \textbf{marca} & \textbf{modelo} & \textbf{total\_multas} \\ \hline
    \endfirsthead
    
    \hline
    \textbf{marca} & \textbf{modelo} & \textbf{total\_multas} \\ \hline
    \endhead
    
    Zitron & Tangerine & 1775 \\ \hline
    Bemev & Berlin & 2304 \\ \hline
    Rinaul & Fuente & 3076 \\ \hline
    Zitron & Orange & 1071 \\ \hline
    Escola & Tercius & 753 \\ \hline
\end{longtable}
\caption{Resumen de las multas de velocidad por marca y modelo}
\end{table}

Como se puede observar, se agrupan el número de sanciones de velocidad por marca y modelo de vehículo de una manera correcta. Además, el número de multas es menor al de la tabla de multas por marca y modelo, pudiendo asumir que la selección por el tipo ``velocidad'' ha sido efectiva.

\end{itemize}

\subsubsection{Querys del análisis estadístico 2}
Se han obtenido los siguientes resultados para las querys del análisis estadístico 2:

\begin{itemize}
    \item \textbf{Exceso de velocidad medio}

\begin{table}[H]
\begin{longtable}{l l l}
    \hline
    \textbf{carretera} & \textbf{media\_velocidad\_registrada} & \textbf{media\_velocidad\_radar} \\ \hline
    \endfirsthead
    
    \hline
    \textbf{carretera} & \textbf{media\_velocidad\_registrada} & \textbf{media\_velocidad\_radar} \\ \hline
    \endhead
    
    A2 & 116 & 100 \\ \hline
    A3 & 116 & 100 \\ \hline
    M30 & 66 & 50 \\ \hline
    M45 & 96 & 80 \\ \hline
    M40 & 96 & 80 \\ \hline
    A6 & 116 & 100 \\ \hline
    A4 & 116 & 100 \\ \hline
    A1 & 117 & 100 \\ \hline
    M50 & 117 & 100 \\ \hline
    A5 & 116 & 100 \\ \hline
    
\end{longtable}
\caption{Resumen de las medias de exceso de velocidad medio}
\end{table}

Estos resultados permiten obtener en la capa de aplicación un porcentaje dividiendo el resultado de ``media velocidad registrada'' entre ``media velocidad radar''. 

    \item \textbf{Tramo y sentido mas conflictivo}

\begin{table}[H]
\begin{longtable}{l l l l}
    \hline
    \textbf{carretera} & \textbf{kilometro} & \textbf{sentido} & \textbf{infracciones\_tramo} \\ \hline
    \endfirsthead
    
    \hline
    \textbf{carretera} & \textbf{kilometro} & \textbf{sentido} & \textbf{infracciones\_tramo} \\ \hline
    \endhead
    
    M45 & 28 & ascending & 202 \\ \hline
    M40 & 43 & descending & 421 \\ \hline
    A1 & 218 & ascending & 184 \\ \hline
    A5 & 53 & ascending & 263 \\ \hline
    M30 & 11 & ascending & 702 \\ \hline
    
\end{longtable}
\caption{Resumen de infracciones por tramo y sentido de carretera}
\end{table}

La query muestra correctamentre el número de infracciones por tramo y dirección de cada carretera, pudiendo escoger el mayor en la capa de aplicación.

\end{itemize}

\subsubsection{Querys del análisis estadístico 3}
Se han obtenido los siguientes resultados para las querys del análisis estadístico 3:

\begin{itemize}
    \item \textbf{Conductores más infractores}

\begin{table}[H]
\begin{longtable}{l l}
    \hline
    \textbf{dni\_deudor} & \textbf{num\_multas} \\ \hline
    \endfirsthead
    
    \hline
    \textbf{dni\_deudor} & \textbf{num\_multas} \\ \hline
    \endhead
    
    63050842E & 525 \\ \hline
    55074832K & 435 \\ \hline
    78135349W & 472 \\ \hline
    12519376Q & 431 \\ \hline
    28232810B & 837 \\ \hline
    
\end{longtable}
\caption{Resumen de multas por DNI del deudor}
\end{table}

La query funciona correctamente, agrupando el número de sanciones por el dni del deudor.

    \item \textbf{Probabilidad de infracción cuando el conductor es distinto al propietario}

\begin{table}[H]
\begin{longtable}{l l}
    \hline
    \textbf{conductor\_igual\_propietario} & \textbf{count} \\ \hline
    \endfirsthead
    
    \hline
    \textbf{conductor\_igual\_propietario} & \textbf{count} \\ \hline
    \endhead
    
    False & 29656 \\ \hline
    True & 19069 \\ \hline
    
\end{longtable}
\caption{Resumen de las coincidencias entre conductor y propietario}
\end{table}

La queery funciona correctamente, devolvienvdo dos filas con las que calcular un porcentaje en la capa de aplicación.

\end{itemize}

\newpage
\section{Conclusiones}

Esta práctica nos ha permitido introducirnos al diseño de bases de datos con la
herramienta \verb!Cassandra! y a la migración de bases de datos a través de
herramientas como \verb!PySpark!. Consideramos crucial la combinación de los
lenguajes de programación con los sistemas de gestión de bases de datos para
lograr un sistema eficiente y una migración completa que nos perita explotar
las características de \verb!Cassandra!.

También destacamos la importancia de crear un modelo adaptado al sistema gestor
de base de datos. En el caso particular de esta práctica, \verb!Cassandra! es
un tipo de base de datos no relacional orientado a columnas optimizado para
lecturas y escrituras masivas. Por lo que las tablas del diseño deben estar
optimizadas para consultas específicas, estructuradas según las necesidades de
acceso y los patrones de consulta previstos. Esto implica diseñar tablas que
minimicen las uniones (joins) y aprovechen al máximo las características clave
de \verb!Cassandra!, como las claves de partición y las claves de agrupamiento
para garantizar una distribución uniforme de los datos y un acceso eficiente.

Además, esta práctica resalta la importancia de comprender las diferencias
entre los sistemas de gestión de bases de datos relacionales y no relacionales.
En \verb!Cassandra!, el modelado de datos se centra en las consultas, por lo
que el diseño debe priorizar el rendimiento y la escalabilidad, sacrificando en
algunos casos la normalización para evitar operaciones costosas.

En cuanto a la migración con \verb!PySpark!, destacamos su capacidad para
manejar grandes volúmenes de datos y transformarlos de manera eficiente, lo que
resulta fundamental en entornos distribuidos. \verb!PySpark! no solo facilita
la extracción y transformación de datos desde fuentes heterogéneas, sino que
también permite integrarlos de manera óptima en un sistema como
\verb!Cassandra!, asegurando consistencia y alta disponibilidad.

En conclusión, esta práctica nos ha permitido integrar nuestros conocimientos
teóricos en bases de datos No SQL con conocimiento práctico en lenguajes de
programación, comprendiendo la importancia de elegir las herramientas adecuadas
para diseñar y migrar bases de datos que satisfagan las necesidades de
escalabilidad y eficiencia de sistemas para la gestión de grandes volúmenes de
información.

\label{sec:conclusion}

\end{document}
