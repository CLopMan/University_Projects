\documentclass[]{article}
\usepackage{graphicx}
\graphicspath{{imagenes/}}
\usepackage[spanish]{babel}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{longtable}
\usepackage{tabularx}

% Configurar el color de los enlaces
\hypersetup{
    colorlinks=true, % Activa el color en los enlaces
    linkcolor=blue,  % Color para los enlaces internos (por ejemplo, tablas de contenido)
    citecolor=black,  % Color para las citas bibliográficas
    filecolor=blue,  % Color para enlaces a archivos
    urlcolor=blue    % Color para los enlaces a URLs
}


\definecolor{miverde}{rgb}{0,0.6,0}
\definecolor{miazul}{rgb}{0.5,0.5,1}
\lstdefinelanguage{cql}{
  morekeywords={SELECT, FROM, WHERE, INSERT, INTO, UPDATE, DELETE, CREATE, TABLE, PRIMARY, KEY, IF, EXISTS, NOT, NULL, AND, OR, SET, USE, VALUES, IN, ALLOW, FILTERING, AS}, % Palabras clave
    ndkeywords={COUNT, AVG},
    ndkeywordstyle=\color{miazul},
  sensitive=false, % Si las palabras clave distinguen mayúsculas de minúsculas
  morecomment=[l]--, % Comentarios de línea (prefijados con "--")
  morecomment=[s]{/*}{*/}, % Comentarios de bloque
  morestring=[b]', % Cadenas entre comillas simples
  morestring=[b]" % Cadenas entre comillas dobles
}


\lstdefinestyle{cql}{
    language=cql,
    backgroundcolor=\color{gray!2},     % Color de fondo
    basicstyle=\ttfamily,               % Tipo y tamaño de fuente
    keywordstyle=\color{blue}\bfseries, % Color para palabras clave
    stringstyle=\color{miverde},        % Color para cadenas
    commentstyle=\color{red},           % Color para comentarios
    showspaces=false,                   % No mostrar espacios
    showstringspaces=false,             % No mostrar espacios en las cadenas
    frame=single,                       % Poner un marco alrededor del código
    breaklines=true,                    % Romper las líneas largas
    captionpos=b,                       % Posición del caption
    tabsize=4,                          % Tamaño de las tabulaciones
    escapeinside={\%*}{*)},             % Para incluir código LaTeX en los listings
    morekeywords={self},                 % Palabras clave adicionales
    extendedchars=true,
    inputencoding=utf8
}

\lstdefinestyle{python}{
    language=Python,
    backgroundcolor=\color{gray!2},     % Color de fondo
    basicstyle=\ttfamily,               % Tipo y tamaño de fuente
    keywordstyle=\color{blue}\bfseries, % Color para palabras clave
    stringstyle=\color{miverde},        % Color para cadenas
    commentstyle=\color{red},           % Color para comentarios
    showspaces=false,                   % No mostrar espacios
    showstringspaces=false,             % No mostrar espacios en las cadenas
    frame=single,                       % Poner un marco alrededor del código
    breaklines=true,                    % Romper las líneas largas
    captionpos=b,                       % Posición del caption
    tabsize=4,                          % Tamaño de las tabulaciones
    escapeinside={\%*}{*)},             % Para incluir código LaTeX en los listings
    morekeywords={self}                 % Palabras clave adicionales
}
%title
\title{Práctica 1} 

\author{Adrián Ferández Galán, César López Mantecón y Manuel Gómez-Plana Rodríguez}

\begin{document}

\begin{titlepage}
    \centering
   \includegraphics[width=0.9\textwidth]{uc3m.jpg} 
    {\Huge Universidad Carlos III\\
    
     \Large Arquitectura de Datos\\
     \vspace{0.5cm}
     Curso 2024-25}
    \vspace{2cm}

    {\Huge \textbf{Práctica 2} \par}
    \vspace{0.5cm}
    {\Large Migración de una base de datos a \texttt{Cassandra} \par}
    \vspace{8cm}

   \textbf{Ingeniería Informática, Cuarto curso}\\
    \vspace{0.2cm} 
    Adrián Fernández Galán       (NIA: 100472182, e-mail: 100472182@alumnos.uc3m.es)\\
    César López Mantecón         (NIA: 100472092, e-mail: 100472092@alumnos.uc3m.es)\\
    Manuel Gómez-Plana Rodríguez (NIA: 100472310, e-mail: 100472310@alumnos.uc3m.es)
    \vspace{0.5cm}

   
    \textbf{Prof .} Lourdes Moreno López\\
    
    \textbf{Grupo: } 81   
    
\end{titlepage}
\newpage

\renewcommand{\contentsname}{\centering Índice}

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=blue}
\newpage

\section{Introducción}
\label{sec:introduccion}
En este documento se recoge la parte de diseño para el desarrollo de la práctica 2 de la asignatura
\textit{Arquitectura de Datos}. En esta práctica se tratará de completar una
migración de una base de datos desde \texttt{MongoDB} a \texttt{Cassandra}.
Además, se computarán nuevas tablas con el fin de permitir el análisis
estadístico, aprovechando las cualidades de \texttt{Cassandra} para el análisis
de datos gracias a su capacidad para la consulta masiva de datos de una misma
columna.

La metodología usada para el desarrollo de este proyecto ha sido la siguiente:
análisis de datos y casos de uso, realización del diseño lógico y físico
orientado a \texttt{Cassandra} e implementación de casos de uso en forma e
consulta. Adicionalmente se empleará la herramienta \texttt{PySpark} para
realizar el primer volcado de datos.

En el diseño de consultas se tratará de aprovechar al máximo las capacidades de
\texttt{Cassandra} en la lectura y escritura, dejando a la aplicación otra clase de
operaciones. De esta forma, ambos sistemas trabajarán en conjunto, garantizando
la eficiencia de la aplicación.


% =======
% Para la realización de esta práctica se busca realizar una migración de datos desde el gestor de bases de datos \textit{Mongodb} a \textit{Cassandra}, además de suplir una serie de casos de uso 
% 
% Esta práctica se basa en la migración de un sistema gestor de expedientes de sanciones que se encontraba en el gestor de bases de datos \textit{Mongodb} y se quiere mover a \textit{Cassandra}, además de implementar nuevos casos de uso. 
% Para ello se realizará un estudio de los datos almacenados en \textit{mongodb} y de los casos de uso propuestos. Tras esto se desarrollará un diseño lógico y físico de la base de datos en \textit{Cassandra} que nos faciliten la creación de las tablas en este mismo gestor de bases de datos y la implementación de las consultas enfocadas a los casos de uso.
% Con las tablas configuradas se insertarán los antiguos datos a través de la herramienta \textit{PySpark}, para finalmente probar el correcto funcionamiento del nuevo sistema.

\section{Modelo de Información del nuevo sistema}
\label{sec:modelo_informacion}

Para completar la migración es necesario realizar un estudio de los datos almacenados en el antiguo modelo. Como la anterior gestión de los datos se realizaba en el gestor de bases de datos \textit{MongoDB} se tiene un \texttt{json} con todos los datos.

Observando las características del \texttt{json} con la información del anterior sistema podemos sacar las siguientes conclusiones:
\begin{itemize}
    \item El antiguo sistema almacena registro sobre los vehículos que han circulado por diferentes autovías, este registro se ha hecho a través de grabaciones realizadas por los diferentes radares situados por las autovías.
    \item El sistema también gestiona sanciones ya emitidas como multas por velocidad (\textit{speed ticket}), cargos administrativos (\textit{clearance ticket}) y multas en zonas de radar de tramo (\textit{stretch ticket}).
    \item Para cada uno de los registros se pueden identificar los siguientes elementos:
    \begin{itemize}
        \item Una autovía o carretera
        \item Un radar en un kilometro determinado de la carretera
        \item Un vehículo que ha cruzado el radar
        \item El vehículo consta de información del conductor en ese momento y del propietario del vehículo
        \item Una grabación realizada por el radar sobre el vehículo en cuestión
    \end{itemize} 
\end{itemize}

Con el objetivo de entender el dominio del problema se ha creado un diagrama de clases en formato UML que nos permita entender los elementos que se tienen en el sistema y cómo estos se relacionan entre sí.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{./imagenes/diagramaUML.png}
    \caption{Diagrama de clases}
    \label{fig:clases}
\end{figure}

\newpage


\section{Análisis de los Casos de Uso y diseño de consultas}
\label{sec:analisis_casos_de_uso}

Para poder desarrollar el nuevo sistema es necesario entender a la perfección
los casos de uso que se nos plantean. A continuación se analizan los
distintos casos de uso que se presentan.

Los casos de uso se pueden dividir según su finalidad:
\begin{itemize}
    \item \textbf{Por funciones operativas}: Aquellos casos de uso que tienen como objetivo generar nuevas funcionalidades.
    \item \textbf{Para análisis estadístico}: Aquellos casos de uso que tienen como objetivo organizar la información de tal manera que pueda realizarse un análisis estadístico sobre ella.
\end{itemize}

\subsection{Funciones Operativas}
\label{subsec:funciones_operativas}

Encontramos dos casos de uso enfocados a las funciones operativas.
\begin{itemize}
    \item \textbf{Emisión de sanciones:}
    
    Este caso de uso busca generar nuevas sanciones a aquellos conductores que no cumplen con una serie de condiciones relacionadas con la velocidad del coche durante el tramo de radar, la situación personal del conductor identificado, el estado de las revisiones técnicas del vehículos y otros factores.
    A continuación se realizará descripción de las condiciones que generarán una nueva sanción:
    \begin{itemize}
        \item \textit{Discrepancia en el carné de conducir del conductor}: En aquellos casos en los que la fecha de obtención del permiso de conducir no sea superior a la fecha de nacimiento del conductor en 18 años.
        \item \textit{Conducción con el vehículo deficiente}: Un coche se considera deficiente si en su última revisión se ha identificado algún defecto. 
        \item \textit{Impago de sanciones emitidas}: Se generará una nueva sanción a aquellos conductores no hayan realizado el pago durante la fecha prevista, dado que no se tiene el conocimiento de esta fecha se tomará una fecha que corresponda con la mediana de todas las fechas existentes en la base de datos.
    \end{itemize}

    Con el objetivo de cumplir este caso de uso se ha generado una tabla llamada \texttt{sanciones}. En esta tabla se recopilarán todas las sanciones de cualquier tipo, tanto generadas como las emitidas. Para ello se generará la siguiente tabla:
\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Sanciones}} \\ 
        \midrule
        dni\_deudor      & text & K \\
        tipo             & text & C↑\\
        fecha\_grabacion & date & C↓\\
        cantidad         & int  &   \\
        dni\_conductor   & text &   \\
        dni\_propietario & text &   \\
        estado           & text &   \\
        matrícula        & text &   \\
        \bottomrule
    \end{tabular}
    \caption {Tabla SANCIONES}
 \end{table}

    Tal y como funciona \textit{Cassandra} es necesario crear una tabla vaya de la mano de la consulta. Para satisfacer el caso de uso se realizará a través de la siguiente consulta:
    \lstset{style=cql}
    \begin{lstlisting}[language=cql, caption=Consulta de todas las sanciones]
SELECT * from Sanciones WHERE dni_deudor = '12345678X' AND tipo IN ('discrepancia carne', 'desperfectos', 'impago') 
    \end{lstlisting}

    Como se puede observar para poder realizar esta consulta en
    \textit{Cassandra} es necesario que el \textit{DNI} y \textit{Tipo} formen
    parte de la clave primaria de la tabla. Además, la elección de
    \textit{Fecha} como clave de \textit{clustering} permite ordenar todas las
    sanciones generadas y concede control en la unicidad de los registros. 

    \item \textbf{Apertura de un proceso ejecutivo para expedientes activos sin plazo de pago cerrado:}
    
    Este caso de uso busca identificar aquellos expedientes que continuan
    activos pero su plazo de pago no ha sido cerrado, para posteriormente abrir
    un proceso ejecutivo realizado por otro sistema de gestión de la DGT que
    permita avisar a los conductores para que realicen su pago. Esta
    funcionalidad se contempla en la siguiente consulta sobre la tabla
    anterior: 
\vspace{0.3cm}

\begin{lstlisting}[language=cql, caption=Consulta de las sanciones pendientes de pago]
SELECT * from Sanciones WHERE estado='stand_by' ALLOW FILTERING; 
\end{lstlisting}

En este caso es necesario incluir la \textit{flag} \texttt{ALLOW FILTERING}
debido a que las claves primaria y de clustering no forman parte de la
condición de búsqueda. Sin embargo, ya que es necesario comprobar todos los
registros para extraer aquellos con el estado adecuado no presenta un problema.
\end{itemize}

\subsection{Análisis Estadístico}
\label{subsec:analisis_estadistico}

Para el análisis estadístico la DGT está interesada en los siguientes estudios:
\begin{itemize}
    \item Estudio por marcas y modelos

    Este caso de uso busca realizar un estudio sobre las marcas y modelos de coches que más infracciones cometen. Es por ello que se exigen tres análisis:
    
    \begin{enumerate}
        \item Número de multas por marca y modelo del vehículo
        \item Los tres colores más multados de coches
        \item Las marcas y modelos de los vehículos con más infracciones por velocidad
    \end{enumerate}

    Se han elaborado dos tablas distintas sobre las que hacer las consultas en \texttt{Cassandra} que permitan obtener cada una de estas estadísticas. Las tablas tienen la siguiente forma:
\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Multas por marca y modelo}} \\ 
        \midrule
        marca              & text & K\\
        modelo             & text & K\\
        matricula          & text & C↓\\
        fecha\_grabacion   & text & C↓\\
        tipo               & text &  \\
        \bottomrule
    \end{tabular}
    \caption {Tabla MULTAS\_MARCA\_MODELO}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Multas por color}} \\ 
        \midrule
        color            & text & K\\
        matricula        & text & C↓\\
        fecha\_grabacion & date & C↓\\
        \bottomrule
    \end{tabular}
    \caption {Tabla MULTAS\_COLOR}
\end{table}
    
    La primera tabla recoge todas las sanciones con la marca y el modelo como claves de partición. De esta forma la consulta relativa a este caso de uso será más eficiente.

    A continuación se incluyen las consultas realizadas sobre estas tablas:

    \lstset{style=cql}
    \begin{lstlisting}[language=cql, caption=Querys para el caso de uso 1]
// Query para el numero de multas por marca y modelo
SELECT marca, modelo, COUNT(*) as total_multas FROM multas_marca_modelo GROUP BY marca, modelo;

// Query para el numero de multas por color
SELECT color, COUNT(*) as total_multas from multas_color_coche GROUP BY color;

// Query para sacar las marcas y modelos de los vehiculos con mas infracciones por velocidad
SELECT marca, modelo, COUNT(*) as total_multas FROM multas_marca_modelo WHERE tipo = 'velocidad' GROUP BY marca, modelo ALLOW FILTERING;
    \end{lstlisting}

    Para la primera y tercera consulta, se obtienen directamente los datos que
    se piden para el caso de uso. En el caso de la consulta 2, se obtienen
    todas las multas para cada color y se deja como responsabilidad de la
    aplicación obtener los tres registros con mayor número de multas. Esto último
    es necesario ya que \texttt{Cassandra} sólo soporta ordenar en una única
    partición. No obstante, los datos de esta consulta podrían estar
    distribuidos en varios nodos.

    \item Estudio por carreteras

    Este caso de uso busca realizar un estudio sobre las carreteras más
    conflictivas de España, haciendo un análisis del exceso de velocidad medio
    en carreteras, así como los tramos donde más infracciones se han cometido.
    Es por ello que se pide lo siguiente:

    \begin{enumerate}
        \item Exceso de velocidad medio para una carretera determinada
        \item Tramo y sentido más conflictivo de una carretera 
    \end{enumerate}

    Se han elaborado dos tablas distintas sobre las que hacer las consultas en
    \texttt{Cassandra} que permitan obtener cada una de estadísticas. Las
    tablas tienen la siguiente forma:  

    \begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Exceso de Velocidad Medio Por Carretera}} \\ 
            \midrule
            carretera        & text & K\\
            fecha\_grabacion & date & C↓\\
            velocidad\_registrada & int & \\
            velocidad\_limite\_radar & int & \\
            \bottomrule
        \end{tabular}
        \caption {Tabla EXCESO\_VELOCIDAD\_CARRETERA}
    \end{table}

    \begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Tramo y Sentido más Conflicto por Carretera}} \\ 
            \midrule
            carretera     & text & K\\
            fecha\_grabacion & date & C↓\\
            kilometro     & int & \\
            sentido       & text& \\
            \bottomrule
        \end{tabular}
        \caption {Tabla CONFLICTO\_TRAMO\_SENTIDO}
    \end{table}

    Las consultas para obtener las estadísticas son las siguientes:

    \begin{lstlisting}[language=cql, caption=Consultas para el caso de uso 2]
// Query para el exceso de velocidad medio para una carretera determinada
SELECT carretera, AVG(velocidad_registrada) as media_velocidad_registrada, AVG(velocidad_limite_radar) as media_velocidad_radar FROM exceso_velocidad_carretera GROUP BY carretera;

// Query para el tramo y sentido mas conflictivo de una carretera
SELECT carretera, kilometro, sentido, COUNT(*) as infracciones_tramo FROM conflictos_tramo_sentido GROUP BY carretera, kilometro, sentido;
    \end{lstlisting}

    La primera consulta devuele el promedio de las velocidades esperadas en un tramo y las registradas para conches infractores. La segunda consulta permite conocer el número de infracciones para cada tramo de cada carretera, de forma que la aplicación pueda seleccionar aquellos registros con mayor número de multas.

    Adicionalmente, se puede modificar ligeramente la consulta en caso de querer seleccionar los registros para una única carretera. En este caso sería necesario usar la \textit{flag} \texttt{ALLOW FILTERING} debido a que la condición where no agrupa todos los atributos de la clave de partición. 

\begin{lstlisting}[language=cql, caption=Querys modificada para el caso de uso 2]
// Query para el tramo y sentido mas conflictivo de una carretera concreta
SELECT carretera, kilometro, sentido, COUNT(*) as infracciones_tramo FROM conflictos_tramo_sentido  where carretera = 'A2' GROUP BY carretera, kilometro, sentido ALLOW FILTERING;
    \end{lstlisting}

 
    \item Estudio por conductores

    El último caso de uso busca realizar un estudio sobre los conductores,
    concretamente, buscan determinar los conductores más infractores, así como
    la probabilidad de que se cometa una infracción cuando un vehículo no es
    conducido por el dueño del mismo.

    Para determinar qué conductores son los más infractores se ha diseñado la siguiente consulta sobre la tabla sanciones:
    \begin{lstlisting}[language=cql, caption=Consulta para obtener los conductores más infractores]
SELECT dni_deudor, COUNT(*) as num_multas FROM sanciones GROUP BY dni_deudor;
    \end{lstlisting}

    Esta consulta devuelve el número de infracciones para cada conductor, de forma que la aplicación pueda seleccionar fácilmente el valor más alto del registro.

    Para obtener la probabilidad de que un infractor sea el propietario del coche se ha diseñado una tabla adicional con la siguiente forma:

    \begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Probabilidad de infracción}} \\ 
            \midrule
            conductor\_igual\_propietario & boolean & K\\
            matricula        & text      & C↓\\
            fecha\_grabacion & timestamp & C↓\\
            \bottomrule
        \end{tabular}
        \caption {Tabla CONDUCTORES\_MAS\_INFRACTORES}
     \end{table}

    El valor requerido es el resultado de la siguiente fórmula: 

    $$P = \frac{\text{num\_conductor\_eq\_propietario}}{\text{num\_multas}}$$

    Estos dos valores se pueden obtener fácilmente mediante dos consultas:

    \begin{lstlisting}[language=cql, caption=Querys para el caso de uso 3]
// Obtencion del numero de multas totales
SELECT COUNT(*) FROM sanciones;
// Obtencion del numero de infracciones con conductor = propietario
select conductor_igual_propietario, count(*) from probabilidad_infraccion GROUP BY conductor_igual_propietario;
    \end{lstlisting}
\end{itemize}

    Con ambos valores la aplicación puede calcular el valor requerido, garantizando la resolución eficiente de este caso de uso.

\section{Modelo Lógico y Físico}
\label{sec:modelo_logico_fisico}

Tras presentar los casos de uso y cómo estos casos de uso derivan en sus
respectivas consultas y tablas, estudiaremos cómo se ha realizado el modelo
completo del sistema para conseguir que dichas tablas se carguen con
los datos necesarios.

\subsection{Modelo Lógico}

\subsubsection{Sanciones}

El primer enfoque que se ha considerado es conseguir alimentar la tabla
\textbf{Sanciones} con aquellas personas que tenga algún tipo de sanción. Por
lo que para alimentar esta tabla tenemos que tratar dos grupos de sanciones:
sanciones generadas y sanciones emitidas previamente.

\begin{itemize}
    \item \textbf{Sanciones ya generadas}: En los datos originales encontramos
    sanciones ya emitidas con anterioridad como lo son \textit{Speed Ticket},
    \textit{Clearance Ticket} y \textit{Stretch Ticket}, por lo que ha creado
    un \textit{dataframe} en \textit{Pyspark} para cada una de estas multas.

    \item \textbf{Nuevas sanciones}: Para generar nuevas sanciones se han
    contemplado las condiciones descritas en el punto \ref{subsec:funciones_operativas}.
    Para cada una de
    ellas se ha generado un \textit{dataframe} en \textit{Pyspark} que parte de
    los datos del \textit{JSON}, excepto en el caso de \textit{impago de
    sanciones} que utilizará los dataframes de las multas para conocer qué
    conductores deben de recibir otra infracción. En cada uno de los
    \textit{dataframes} se insertarán los datos que cumplan la condición, de
    manera que solo contengan los datos de aquellos conductores infractores.
    Finalmente los \textit{dataframes} creados han sido los siguientes:
    \texttt{Discrepancia\_Carnet}, \texttt{Vehiculo\_Deficiente},
    \texttt{Impago\_Sanciones}
\end{itemize}

Cada de uno de los \textit{dataframes} mencionados tendrá únicamente los
atributos necesarios para alimentar la tabla de \textit{Sanciones} y cualquier
otra tabla que satisfaga a un caso de uso.
La tabla \textit{Sanciones} será la unión de algunos atributos de cada una de
los \textit{dataframes} mencionados. Tal como se ha indicado en el anterior
punto, \textit{Sanciones} cuenta con los atributos \texttt{dni\_deudor},
\texttt{dni\_propietario}, \verb!dni_conductor!, \verb!fecha_grabacion!,
\verb!matricula!, \verb!cantidad!, y \verb!estado!; por lo que será necesario que los \textit{dataframes} tengan esta
información, o al menos pueda ser obtenida de algún modo. Esta nueva tabla será
insertada en \texttt{Cassandra}.

Para ello los \textit{dataframes} anteriores contarán con \texttt{dni\_deudor}, \texttt{fecha\_grabación}, \texttt{matricula}; y si son sanciones emitidas previamente se usará su estado, tipo y cantidad, en cambio para las sanciones generadas se les dotará de una cantidad, el estado de \texttt{stand\_by} y el tipo según la procedencia de la multa.

A continuación se puede ver un diagrama que recoge el proceso de migración para la creación de la tabla \textit{Sanciones}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./imagenes/Sanciones.png}
    \caption{Modelo lógico de Sanciones}
    \label{fig:modelo_sanciones}
\end{figure}

En verde se representan los \textit{dataframes} auxiliares que se construyen en \textit{Pyspark}.

\subsubsection{Multas por marca y modelo o por color}

Estas dos tablas se alimentan de datos de los vehículos y de las sanciones.
Para cumplir con la funcionalidad descrita en los casos de uso y tal y cómo se
expuso en el punto \ref{subsec:analisis_estadistico} es necesario que estas
tablas contengan los siguientes datos: 

\begin{itemize}
    \item\textbf{Multas por marca y modelo}: \verb!matricula!, \verb!modelo!,
    \verb!marca!, \verb!fecha_grabacion! y \verb!tipo_multa!.
    \item\textbf{Multas por color}: \verb!color!, \verb!fecha_grabacion! y \verb!matricula!.
\end{itemize}

El proceso de migración que se ha seguido para alimentar estas tablas viene recogido en el siguiente diagrama:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{./imagenes/multas_estadistica.png}
    \caption{Modelo lógico de Multas por Color y Multas por marca y modelo}
\end{figure}

\subsubsection{Tramo conflictivo y exceso de velocidad medio}

Las tablas con información relativa al tramo más conflictivo y el exceso de velocidad medio contienen los siguientes datos: 

\begin{itemize}
    \item\textbf{Tramo conflictivo}: \verb!carretera!, \verb!kilometro!, \verb!sentido! y \verb!fecha_grabacion!.
    \item\textbf{Exceso de velocidad medio}: \verb!carretera!, \verb!velocidad_registrada!, \verb!velocidad_limite_radar! y \verb!fecha_grabacion!.
\end{itemize}

Es por eso que necesitan alimentarse exclusivamente de información relativa a las multas por exceso de velocidad, tal y como se representa en el siguiente diagrama:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./imagenes/tramo_y_velocidad.png}
    \caption{Modelo lógico de Tramos conflictivos y Exceso de velocidad medio}
\end{figure}

\subsubsection{Probabilidad de infracción}

La tabla con información relativa al caso de uso 3, es decir, el análisis de la probabilidad de infracción cuando el conductor de un vehículo multado es distinto al propietario, contiene los siguientes datos: 
\begin{itemize}
    \item\textbf{Conductor igual a propietario}: \verb!conductor_igual_propietario!, \verb!matricula!, y \verb!fecha_grabacion!.
\end{itemize}

Es por ello que necesitan obtener estos datos de la tabla de sanciones, explicada anteriormente,tal y como se puede observar en la siguiente figura:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.25\textwidth]{./imagenes/conductores.png}
    \caption{Modelo lógico de la Probabilidad de multa con conductor igual a propietario}
\end{figure}

\subsubsection{Diagrama completo}

Con todo lo anterior, el diagrama que representa la nueva base de datos, así como el proceso de migración es el siguiente:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./imagenes/modelo_migracion.png}
    \caption{Modelo lógico completo}
\end{figure}

\subsection{Modelo físico}
\label{subsec:modelo_fisico}

\subsubsection{Definición de keyspace}
\label{subsec:keyspace}
Pese a que pudiera parecer que existen dos contextos funcionales distintos
(funciones operativas y análisis estadístico), dado que las tablas contienen
información redundante en muchos casos y que existen relaciones claras entre
todas ellas se ha decidido mantener toda la base de datos en un único
\textit{keyspace} llamado \texttt{practica2}. Este nombre, pese a no ser
representativo de la base de datos, se ha elegido por ser muy fácilmente
distinguible en la máquina virtual de otras bases de datos resultado de otros
ejercicios. En un contexto laboral se debería cambiar por un nombre más
representativo de la naturaleza de los datos como \textit{DatosSancionesDGT} o
similares.

\subsubsection{Elección de tipos}

Los tipos de datos han sido contemplados en el modelo lógico. Aunque no sea una
decisión común en ese ámbito se ha decidido seguir esa aproximación para
permitirnos tener una primera estimación durante la fase de diseño de las
necesidades de almacenamiento y particularidades del \textit{pipeline} de
migración, así como conversiones necesarias de tipos o posibles correcciones
que hacer sobre los datos.

A continuación se incluye un resumen de las tablas: 

\begin{minipage}{0.45\textwidth}
\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Sanciones}} \\ 
        \midrule
        dni\_deudor      & text & K \\
        tipo             & text & C↑\\
        fecha\_grabacion & date & C↓\\
        cantidad         & int  &   \\
        dni\_conductor   & text &   \\
        dni\_propietario & text &   \\
        estado           & text &   \\
        matrícula        & text &   \\
        \bottomrule
    \end{tabular}
\end{table}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Multas por marca y modelo}} \\ 
        \midrule
        marca              & text & K\\
        modelo             & text & K\\
        matricula          & text & C↓\\
        fecha\_grabacion   & text & C↓\\
        tipo               & text &  \\
        \bottomrule
    \end{tabular}
\end{table}
\end{minipage}


\begin{minipage}{0.45\textwidth}
\begin{table}[H]
    \centering
    \begin{tabular}{lll} 
        \toprule
        \multicolumn{3}{c}{\large\textbf{Multas por color}} \\ 
        \midrule
        color            & text & K\\
        matricula        & text & C↓\\
        fecha\_grabacion & date & C↓\\
        \bottomrule
    \end{tabular}
\end{table}
\end{minipage}
\begin{minipage}{0.45\textwidth}
    \begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Exceso de Velocidad Medio Por Carretera}} \\ 
            \midrule
            carretera        & text & K\\
            fecha\_grabacion & date & C↓\\
            velocidad\_registrada & int & \\
            velocidad\_limite\_radar & int & \\
            \bottomrule
        \end{tabular}
    \end{table}
\end{minipage}

\begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Tramo y Sentido más Conflicto por Carretera}} \\ 
            \midrule
            carretera     & text & K\\
            fecha\_grabacion & date & C↓\\
            kilometro     & int & \\
            sentido       & text& \\
            \bottomrule
        \end{tabular}
    \end{table}
\begin{table}[H]
        \centering
        \begin{tabular}{lll} 
            \toprule
            \multicolumn{3}{c}{\large\textbf{Probabilidad de infracción}} \\ 
            \midrule
            conductor\_igual\_propietario & boolean & K\\
            matricula        & text      & C↓\\
            fecha\_grabacion & timestamp & C↓\\
            \bottomrule
        \end{tabular}
     \end{table}


\subsubsection{Dimensionamiento}
\label{subsubsec:dimensionamiento}
Con el objetivo de entender y analizar la escalabilidad, el nivel de
optimización y el balanceo de la carga de trabajo del sistema, se
calcularán los tamaños de las particiones.

Para conocer el número de celdas (valores) que tiene cada partición se usará la siguiente fórmula:

$$N_v = N_r \cdot (N_c - N_{pk} - N_s) + N_s$$

\begin{itemize}
    \item $N_v$: Número de valores en la partición
    \item $N_s$: Número de columnas estáticas
    \item $N_r$: Número de filas
    \item $N_c$: Número de columnas
    \item $N_{pk}$: Número de columnas en la pk
\end{itemize}

Con esta fórmula se calcula el número de valores de cada partición para cada
una de las tablas. Para entender cómo se realizarán los cálculos se se
desarrollará la fórmula para una tabla, en este caso se usará la tabla
\textbf{Sanciones}:

\begin{itemize}
    \item Nº de columnas: $N_c = 8$
    \item Nº de columnas en pk: $N_{pk} = 3$
    \item Nº de columnas estáticas: $N_s= 0$
    \item Nº de filas: $N_r = 114049$
\end{itemize}

Obtenidos los datos para la fórmula, sustituimos $$114049 \cdot (8 - 3 - 0) + 0 = 570245 \text{filas por partición}$$

A continuación se muestran los valores por partición para cada tabla:
\begin{itemize}
    \item \textbf{Sanciones}: 570245
    \item \textbf{Multas por Marca y Modelo}: 48725
    \item \textbf{Multas por Color}: 1
    \item \textbf{Conductor igual a propietario}: 1
    \item \textbf{Tramo y Sentido más conflictivo por carretera}: 88362
    \item \textbf{Exceso de Velocidad medio por carretera}: 88362
\end{itemize}

Es importante destacar que para las tablas donde todas las columnas forman
parte de la clave primaria, aunque la formula resulte en $0$, se ha tomado el
valor $1$, dado que cada fila insertada se ubicará en una partición.

Tras calcular el número de filas por partición se calculará el tamaño en disco
de las tablas, esto se conseguirá a través de la siguiente fórmula: 

$$S_t = \sum_i sizeOf(c_k) + \sum_j sizeOf(c_{s_j}) + N_r \cdot (\sum_k sizeOf(c_{r_k}) + \sum_l sizeOf(c_{c_l})) + N_v \cdot sizeOf(t_{avg})$$

\begin{itemize}
    \item $c_k$: Cuenta las columnas que son clave de partición
    \item $c_s$: Cuenta las columnas estáticas
    \item $c_r$: Cuenta las columnas normales
    \item $c_c$: Cuenta las columnas que pertenecen a la clave de clusterización
    \item $t_{avg}$: Promedio de bytes utilizados por Cassandra para almacenar los metadatos de un valor, suele ser 8 bytes
    \item La función \verb!sizeOf()! indica el tamaño en bytes de los tipos CQL utilizados en la definición de cada columna
\end{itemize}

Al igual que para el anterior cálculo, se desarrollará en profundidad el
cálculo del tamaño de una partición de una tabla, de nuevo usaremos
\textbf{Sanciones}:

\begin{itemize}
    \item No tiene columnas estáticas ($c_s = 0$)
    \item Cálculo de bytes por columna
    \begin{itemize}
        \item DNI deudor, es de tipo texto con 9 simbolos = 9 bytes
        \item DNI propietario, 9 bytes
        \item DNI conductor, 9 bytes
        \item Tipo, es de tipo texto y la cadena más larga puede ser de 19 caracteres = 19 bytes
        \item Fecha, timestamp = 8 bytes
        \item Estado, es de tipo texto y la cadena más larga es "fullfied" que tiene 10 caracteres = 10 bytes
        \item Matricula, 7 caracteres = 7 bytes
        \item Cantidad, int = 4 bytes
    \end{itemize}
    \item Suma de columnas de clave de partición = 9 bytes
    \item Suma de columnas de clave de clusterización = 27 bytes
    \item Suma de columnas normales = 29 bytes
\end{itemize}

Con los valores calculados sustituimos en la fórmula 

$$S_t = 9 + 0 + 114049 \cdot (39 + 27) + 570245 \cdot 8 = 10948713 bytes = 12.09 MB$$

A continuación se muestran los tamaños de las particiones de las siguientes tablas:
\begin{itemize}
    \item \textbf{Sanciones}: 12.09 MB
    \item \textbf{Multas por Marca y Modelo}: 2.05 MB
        %marca = Supuesto de 15 bytes
        %modelo = Supuesto de 15 bytes
        %matricula = 7 bytes
        %Fecha = 8 bytes
        %Tipo = 19 bytes
        %N_r = 48725
    \item \textbf{Multas por Color}: 0.73 MB
        %color = Supuesto de 20 bytes
        %Fecha = 8 bytes
        %Matricula = 7 bytes
        %N_r = 48725
    \item \textbf{Conductor igual a propietario}: 0.73 MB
        % Conductor = propietario = 1 bytes (bool)
        % Matricula = 7 bytes
        % Fecha = 8 bytes
        %N_r = 48725
    \item \textbf{Tramo y Sentido más conflictivo por carretera}: 1.5 MB
        %Carretera = Supuesto de 8 bytes
        %Kilometro = 4 bytes (int)
        %Sentido = 10 bytes (text, "descending" son 10 caracteres)
        %Num_infrac = 4 bytes (int)
        %N_r = 44181
    \item \textbf{Exceso de Velocidad medio por carretera}: 1.41 MB
        %Carretera = Supuesto de 8 bytes
        %Fecha = 8 bytes
        %Velocidad registrada = 4 bytes (int)
        %Velocidad radar = 4 bytes (int)
        %N_r = 44181
\end{itemize}

Se ha supuesto que la marca y el modelo no superarán los 15 caracteres, que el
color de los vehiculos no superará los 20 caracteres y que el nombre de la
carretera no supera los 8 caracteres.

El límite de tamaño de una partición en Cassandra es de 2GB, pero se recomienda
que el tamaño sea de 1MB. En nuestro caso todas las tablas tienen una gran
holgura respecto al tamaño máximo de una partición. Sin embargo, únicamente 2
tablas no exceden el tamaño recomendado. Respecto a las demás, existen dos tablas que exceden el tamaño
recomendado por, aproximadamente, 0.5 MB; y una tabla, \textbf{Sanciones},
que supera en un 1200\% el tamaño recomendado.

El tamaño de la tabla \textbf{Sanciones} es un problema a tener en cuenta y
necesario de solucionar. La propuesta más sencilla es añadir una una nueva
columna como clave de partición. Se sugiere usar \textit{Matricula} con este
fin, de forma que se optimicen consultas sobre sanciones que tiene una persona
según los coches que tenga. Este cambio reduce el número de filas por partición
de 570245 a \textbf{456196}, lo que supone que el tamaño de cada partición sea
de \textbf{10.38 MB} y una reducción del \textbf{14\%} del tamaño
con tan solo cambiar un atributo.

Aunque esté lejos del tamaño recomendado, se pueden seguir añadiendo atributos
a la clave de partición según las necesidades emergentes de la base de datos
para seguir reduciendo el tamaño.

\subsubsection{Testeo de rendimiento}

Se han ejecutado las consultas diseñadas en el apartado relativo a los casos de
uso (ver \ref{sec:analisis_casos_de_uso}), logrando obtener la totalidad de los
datos en tiempos muy reducidos. Algunas de estas consultas devuelven grandes
volúmenes de datos, destacando el buen rendimiento de \verb!Cassandra! en
lecturas. Es por esto que concluímos que el rendimiento de la base de datos es
suficiente y no necesita de grandes optimizaciones.

\newpage
\section{Conclusiones}

Esta práctica nos ha permitido introducirnos al diseño de bases de datos con la
herramienta \verb!Cassandra! y a la migración de bases de datos a través de
herramientas como \verb!PySpark!. Consideramos crucial la combinación de los
lenguajes de programación con los sistemas de gestión de bases de datos para
lograr un sistema eficiente y una migración completa que nos perita explotar
las características de \verb!Cassandra!.

También destacamos la importancia de crear un modelo adaptado al sistema gestor
de base de datos. En el caso particular de esta práctica, \verb!Cassandra! es
un tipo de base de datos no relacional orientado a columnas optimizado para
lecturas y escrituras masivas. Por lo que las tablas del diseño deben estar
optimizadas para consultas específicas, estructuradas según las necesidades de
acceso y los patrones de consulta previstos. Esto implica diseñar tablas que
minimicen las uniones (joins) y aprovechen al máximo las características clave
de \verb!Cassandra!, como las claves de partición y las claves de agrupamiento
para garantizar una distribución uniforme de los datos y un acceso eficiente.

Además, esta práctica resalta la importancia de comprender las diferencias
entre los sistemas de gestión de bases de datos relacionales y no relacionales.
En \verb!Cassandra!, el modelado de datos se centra en las consultas, por lo
que el diseño debe priorizar el rendimiento y la escalabilidad, sacrificando en
algunos casos la normalización para evitar operaciones costosas.

En cuanto a la migración con \verb!PySpark!, destacamos su capacidad para
manejar grandes volúmenes de datos y transformarlos de manera eficiente, lo que
resulta fundamental en entornos distribuidos. \verb!PySpark! no solo facilita
la extracción y transformación de datos desde fuentes heterogéneas, sino que
también permite integrarlos de manera óptima en un sistema como
\verb!Cassandra!, asegurando consistencia y alta disponibilidad.

En conclusión, esta práctica nos ha permitido integrar nuestros conocimientos
teóricos en bases de datos No SQL con conocimiento práctico en lenguajes de
programación, comprendiendo la importancia de elegir las herramientas adecuadas
para diseñar y migrar bases de datos que satisfagan las necesidades de
escalabilidad y eficiencia de sistemas para la gestión de grandes volúmenes de
información.

\label{sec:conclusion}

\end{document}
